<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrencia - El Libro de Rust Embebido</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introducción</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hardware.html"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="../intro/no-std.html"><strong aria-hidden="true">1.2.</strong> no_std</a></li><li class="chapter-item expanded "><a href="../intro/tooling.html"><strong aria-hidden="true">1.3.</strong> Herramientas</a></li><li class="chapter-item expanded "><a href="../intro/install.html"><strong aria-hidden="true">1.4.</strong> Instalación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/install/linux.html"><strong aria-hidden="true">1.4.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../intro/install/macos.html"><strong aria-hidden="true">1.4.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="../intro/install/windows.html"><strong aria-hidden="true">1.4.3.</strong> Windows</a></li><li class="chapter-item expanded "><a href="../intro/install/verify.html"><strong aria-hidden="true">1.4.4.</strong> Verificar Instalación</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">2.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/qemu.html"><strong aria-hidden="true">2.1.</strong> QEMU</a></li><li class="chapter-item expanded "><a href="../start/hardware.html"><strong aria-hidden="true">2.2.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="../start/registers.html"><strong aria-hidden="true">2.3.</strong> Registros mapeados en memoria</a></li><li class="chapter-item expanded "><a href="../start/semihosting.html"><strong aria-hidden="true">2.4.</strong> Semihosting</a></li><li class="chapter-item expanded "><a href="../start/panicking.html"><strong aria-hidden="true">2.5.</strong> Pánico</a></li><li class="chapter-item expanded "><a href="../start/exceptions.html"><strong aria-hidden="true">2.6.</strong> Excepciones</a></li><li class="chapter-item expanded "><a href="../start/interrupts.html"><strong aria-hidden="true">2.7.</strong> Interrupciones</a></li><li class="chapter-item expanded "><a href="../start/io.html"><strong aria-hidden="true">2.8.</strong> E/S</a></li></ol></li><li class="chapter-item expanded "><a href="../peripherals/index.html"><strong aria-hidden="true">3.</strong> Periféricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../peripherals/a-first-attempt.html"><strong aria-hidden="true">3.1.</strong> Un primer intento en Rust</a></li><li class="chapter-item expanded "><a href="../peripherals/borrowck.html"><strong aria-hidden="true">3.2.</strong> El comprobador de préstamos</a></li><li class="chapter-item expanded "><a href="../peripherals/singletons.html"><strong aria-hidden="true">3.3.</strong> Singletons</a></li></ol></li><li class="chapter-item expanded "><a href="../static-guarantees/index.html"><strong aria-hidden="true">4.</strong> Garantías estáticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../static-guarantees/typestate-programming.html"><strong aria-hidden="true">4.1.</strong> Programación por Typestate</a></li><li class="chapter-item expanded "><a href="../static-guarantees/state-machines.html"><strong aria-hidden="true">4.2.</strong> Periféricos como máquinas de estado</a></li><li class="chapter-item expanded "><a href="../static-guarantees/design-contracts.html"><strong aria-hidden="true">4.3.</strong> Contratos de diseño</a></li><li class="chapter-item expanded "><a href="../static-guarantees/zero-cost-abstractions.html"><strong aria-hidden="true">4.4.</strong> Abstracciones de costo cero</a></li></ol></li><li class="chapter-item expanded "><a href="../portability/index.html"><strong aria-hidden="true">5.</strong> Portabilidad</a></li><li class="chapter-item expanded "><a href="../concurrency/index.html" class="active"><strong aria-hidden="true">6.</strong> Concurrencia</a></li><li class="chapter-item expanded "><a href="../collections/index.html"><strong aria-hidden="true">7.</strong> Colecciones</a></li><li class="chapter-item expanded "><a href="../design-patterns/index.html"><strong aria-hidden="true">8.</strong> Design Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/index.html"><strong aria-hidden="true">8.1.</strong> HALs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/checklist.html"><strong aria-hidden="true">8.1.1.</strong> Lista de chequeo</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/naming.html"><strong aria-hidden="true">8.1.2.</strong> Nomenclatura</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/interoperability.html"><strong aria-hidden="true">8.1.3.</strong> Interoperabilidad</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/predictability.html"><strong aria-hidden="true">8.1.4.</strong> Previsibilidad</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/gpio.html"><strong aria-hidden="true">8.1.5.</strong> GPIO</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../c-tips/index.html"><strong aria-hidden="true">9.</strong> Consejos para desarrolladores de C embebido</a></li><li class="chapter-item expanded "><a href="../interoperability/index.html"><strong aria-hidden="true">10.</strong> Interoperabilidad</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interoperability/c-with-rust.html"><strong aria-hidden="true">10.1.</strong> Un poco de C con tu Rust</a></li><li class="chapter-item expanded "><a href="../interoperability/rust-with-c.html"><strong aria-hidden="true">10.2.</strong> Un poco de Rust con tu C</a></li></ol></li><li class="chapter-item expanded "><a href="../unsorted/index.html"><strong aria-hidden="true">11.</strong> Temas sin clasificar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsorted/speed-vs-size.html"><strong aria-hidden="true">11.1.</strong> Optimizaciones: El equilibrio entre velocidad y tamaño</a></li><li class="chapter-item expanded "><a href="../unsorted/math.html"><strong aria-hidden="true">11.2.</strong> Realización de funciones matemáticas</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../appendix/glossary.html">Apéndice A: Glosario</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Libro de Rust Embebido</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/idio/rust-embedded-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="concurrencia"><a class="header" href="#concurrencia">Concurrencia</a></h1>
<p>La concurrencia se produce cuando diferentes partes del programa se ejecutan en momentos diferentes o fuera de orden. En un contexto embebido, esto incluye:</p>
<ul>
<li>Manejadores de interrupción, que se ejecutan cada vez que se produce la interrupción asociada,</li>
<li>varias formas de multihilo, en las que el microprocesador intercambia regularmente partes del programa,</li>
<li>y, en algunos sistemas, microprocesadores multinúcleo, en los que cada núcleo puede ejecutar de forma independiente una parte diferente del programa al mismo tiempo.</li>
</ul>
<p>Dado que muchos programas embebidos necesitan lidiar con interrupciones, la concurrencia aparecerá tarde o temprano, y es también donde muchos errores sutiles y difíciles pueden ocurrir. Afortunadamente, Rust proporciona una serie de abstracciones y garantías de seguridad para ayudarnos a escribir código correcto.</p>
<h2 id="sin-concurrencia"><a class="header" href="#sin-concurrencia">Sin concurrencia</a></h2>
<p>La concurrencia más simple para un programa embebido es la no concurrencia: tu software consiste en un único bucle principal que sigue corriendo, y no hay interrupciones en absoluto. A veces esto es perfectamente adecuado para el problema en cuestión. Normalmente, el bucle leerá algunas entradas, realizará algún procesamiento y escribirá algunas salidas.</p>
<pre><code class="language-rust ignore">#[entry]
fn main() {
    let peripherals = setup_peripherals();
    loop {
        let inputs = read_inputs(&amp;peripherals);
        let outputs = process(inputs);
        write_outputs(&amp;peripherals, outputs);
    }
}</code></pre>
<p>Como no hay concurrencia, no hay necesidad de preocuparse por compartir datos entre partes de tu programa o sincronizar el acceso a los periféricos. Si puedes salirte con la tuya con un enfoque tan simple esta puede ser una gran solución.</p>
<h2 id="datos-mutables-globales"><a class="header" href="#datos-mutables-globales">Datos Mutables Globales</a></h2>
<p>A diferencia del Rust no embebido, normalmente no tendremos el lujo de crear asignaciones de heap y pasar referencias a esos datos a un hilo recién creado. En su lugar, nuestros manejadores de interrupciones pueden ser llamados en cualquier momento y deben saber cómo acceder a cualquier memoria compartida que estemos utilizando. En el nivel más bajo, esto significa que debemos tener memoria mutable <em>asignada estáticamente</em>, a la que tanto el manejador de interrupciones como el código principal puedan referirse.</p>
<p>En Rust, tales variables <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a> son siempre inseguras para leer o escribir, porque sin tener especial cuidado, podrías provocar una condición de carrera, donde tu acceso a la variable es interrumpido a mitad de camino por una interrupción que también accede a esa variable.</p>
<p>Para un ejemplo de cómo este comportamiento puede causar errores sutiles en tu código, considera un programa embebido que cuenta los flancos ascendentes de alguna señal de entrada en cada periodo de un segundo (un contador de frecuencia):</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // DANGER - Not actually safe! Could cause data races.
            unsafe { COUNTER += 1 };
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>Cada segundo, la interrupción del temporizador vuelve a poner el contador a 0. Mientras tanto, el bucle principal mide continuamente la señal, e incrementa el contador cuando ve un cambio de bajo a alto. Hemos tenido que usar <code>unsafe</code> para acceder a <code>COUNTER</code>, ya que es <code>static mut</code>, y eso significa que estamos prometiendo al compilador que no causaremos ningún comportamiento indefinido. ¿Puedes detectar la condición de carrera? El incremento en <code>COUNTER</code> <em>no</em> está garantizado que sea atómico - de hecho, en la mayoría de las plataformas embebidas, se dividirá en una carga, luego el incremento, y luego un almacenamiento. Si la interrupción se disparara después de la carga pero antes del almacenamiento, el reset a 0 sería ignorado después de que la interrupción volviera - y contaríamos el doble de transiciones para ese periodo.</p>
<h2 id="secciones-críticas"><a class="header" href="#secciones-críticas">Secciones críticas</a></h2>
<p>Entonces, ¿qué podemos hacer con las carreras de datos? Un enfoque sencillo es utilizar <em>secciones críticas</em>, un contexto en el que las interrupciones están deshabilitadas. Envolviendo el acceso a <code>COUNTER</code> en <code>main</code> en una sección crítica, podemos estar seguros de que la interrupción del temporizador no se disparará hasta que hayamos terminado de incrementar <code>COUNTER</code>:</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // New critical section ensures synchronised access to COUNTER
            cortex_m::interrupt::free(|_| {
                unsafe { COUNTER += 1 };
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>En este ejemplo, usamos <code>cortex_m::interrupt::free</code>, pero otras plataformas tendrán mecanismos similares para ejecutar código en una sección crítica. Esto también es lo mismo que desactivar las interrupciones, ejecutar algo de código, y luego volver a activar las interrupciones.</p>
<p>Observa que no necesitamos poner una sección crítica dentro de la interrupción del temporizador, por dos razones:</p>
<ul>
<li>Escribir 0 en <code>COUNTER</code> no puede verse afectado por una carrera ya que no lo leemos.</li>
<li>De todas formas nunca será interrumpido por el hilo `main</li>
</ul>
<p>Si <code>COUNTER</code> estuviera siendo compartido por múltiples manejadores de interrupción que pudieran <em>prevenir</em> a cada uno, entonces cada uno podría requerir una sección crítica también.</p>
<p>Esto resuelve nuestro problema inmediato, pero seguimos escribiendo mucho código inseguro sobre el que tenemos que razonar cuidadosamente, y podríamos estar usando secciones críticas innecesariamente. Dado que cada sección crítica pausa temporalmente el procesamiento de interrupciones, hay un costo asociado de algún tamaño de código extra y mayor latencia de interrupción y jitter (las interrupciones pueden tardar más en ser procesadas, y el tiempo hasta que son procesadas será más variable). Que esto sea un problema depende de tu sistema, pero en general, nos gustaría evitarlo.</p>
<p>Vale la pena señalar que, si bien una sección crítica garantiza que no se produzcan interrupciones, ¡no proporciona una garantía de exclusividad en sistemas multinúcleo!  El otro núcleo podría estar accediendo felizmente a la misma memoria que tu núcleo, incluso sin interrupciones. Necesitarás primitivas de sincronización más fuertes si estás usando múltiples núcleos.</p>
<h2 id="acceso-atómico"><a class="header" href="#acceso-atómico">Acceso atómico</a></h2>
<p>En algunas plataformas existen instrucciones atómicas especiales que garantizan las operaciones de lectura-modificación-escritura. Específicamente para Cortex-M: <code>thumbv6</code> (Cortex-M0, Cortex-M0+) sólo proporciona instrucciones atómicas de carga y almacenamiento, mientras que <code>thumbv7</code> (Cortex-M3 y superiores) proporciona instrucciones completas de Comparación e Intercambio (CAS). Estas instrucciones CAS ofrecen una alternativa a la pesada deshabilitación de todas las interrupciones: podemos intentar el incremento, que tendrá éxito la mayoría de las veces, pero si se interrumpe se reintentará automáticamente toda la operación de incremento. Estas operaciones atómicas son seguras incluso en múltiples núcleos.</p>
<pre><code class="language-rust ignore">use core::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // Use `fetch_add` to atomically add 1 to COUNTER
            COUNTER.fetch_add(1, Ordering::Relaxed);
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // Use `store` to write 0 directly to COUNTER
    COUNTER.store(0, Ordering::Relaxed)
}</code></pre>
<p>Esta vez <code>COUNTER</code> es una variable <code>static</code> segura. Gracias al tipo <code>AtomicUsize</code> <code>COUNTER</code> puede modificarse de forma segura tanto desde el manejador de interrupciones como desde el hilo principal sin desactivar las interrupciones. Cuando sea posible, esta es la mejor solución - pero puede que no esté soportada en tu plataforma.</p>
<p>Una nota sobre <a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>: esto afecta a cómo el compilador y el hardware pueden reordenar las instrucciones, y también tiene consecuencias sobre la visibilidad de la caché. Asumiendo que el objetivo es una plataforma mononúcleo, <code>Relaxed</code> es suficiente y la opción más eficiente en este caso particular. Un ordenamiento más estricto hará que el compilador emita barreras de memoria alrededor de las operaciones atómicas; ¡dependiendo de para qué uses las atómicas puedes necesitarlo o no! Los detalles precisos del modelo atómico son complicados y es mejor describirlos en otro lugar.</p>
<p>Para más detalles sobre atómicos y ordenación, vea el <a href="https://doc.rust-lang.org/nomicon/atomics.html">nomicon</a>.</p>
<h2 id="abstracciones-envío-y-sincronización"><a class="header" href="#abstracciones-envío-y-sincronización">Abstracciones, envío y sincronización</a></h2>
<p>Ninguna de las soluciones anteriores es especialmente satisfactoria. Requieren bloques &quot;inseguros&quot; que deben ser comprobados cuidadosamente y no son ergonómicos. ¡Seguramente podemos hacerlo mejor en Rust!</p>
<p>Podemos abstraer nuestro contador en una interfaz segura que pueda ser utilizada con seguridad en cualquier otra parte de nuestro código. Para este ejemplo, usaremos el contador de sección crítica, pero podrías hacer algo muy similar con atomics.</p>
<pre><code class="language-rust ignore">use core::cell::UnsafeCell;
use cortex_m::interrupt;

// Our counter is just a wrapper around UnsafeCell&lt;u32&gt;, which is the heart
// of interior mutability in Rust. By using interior mutability, we can have
// COUNTER be `static` instead of `static mut`, but still able to mutate
// its counter value.
struct CSCounter(UnsafeCell&lt;u32&gt;);

const CS_COUNTER_INIT: CSCounter = CSCounter(UnsafeCell::new(0));

impl CSCounter {
    pub fn reset(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        // By requiring a CriticalSection be passed in, we know we must
        // be operating inside a CriticalSection, and so can confidently
        // use this unsafe block (required to call UnsafeCell::get).
        unsafe { *self.0.get() = 0 };
    }

    pub fn increment(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        unsafe { *self.0.get() += 1 };
    }
}

// Required to allow static CSCounter. See explanation below.
unsafe impl Sync for CSCounter {}

// COUNTER is no longer `mut` as it uses interior mutability;
// therefore it also no longer requires unsafe blocks to access.
static COUNTER: CSCounter = CS_COUNTER_INIT;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // No unsafe here!
            interrupt::free(|cs| COUNTER.increment(cs));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // We do need to enter a critical section here just to obtain a valid
    // cs token, even though we know no other interrupt could pre-empt
    // this one.
    interrupt::free(|cs| COUNTER.reset(cs));

    // We could use unsafe code to generate a fake CriticalSection if we
    // really wanted to, avoiding the overhead:
    // let cs = unsafe { interrupt::CriticalSection::new() };
}</code></pre>
<p>Hemos movido nuestro código inseguro (<code>unsafe</code>) al interior de nuestra abstracción cuidadosamente planificada, y ahora el código de nuestra aplicación no contiene ningún bloque inseguro (<code>unsafe</code>).</p>
<p>Este diseño requiere que la aplicación pase un token <code>CriticalSection</code>: estos tokens sólo son generados de forma segura por <code>interrupt::free</code>, así que al requerir que se pase uno, nos aseguramos de que estamos operando dentro de una sección crítica, sin tener que hacer el bloqueo nosotros mismos. Esta garantía la proporciona estáticamente el compilador: no habrá ninguna sobrecarga en tiempo de ejecución asociada a <code>cs</code>. Si tuviéramos múltiples contadores, a todos se les podría dar el mismo <code>cs</code>, sin necesidad de múltiples secciones críticas anidadas.</p>
<p>Esto también trae a colación un tema importante para la concurrencia en Rust: los <em>traits</em> <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><code>Send</code> y <code>Sync</code></a>. Para resumir el libro de Rust, un tipo es Send cuando puede ser movido con seguridad a otro hilo, mientras que es Sync cuando puede ser compartido con seguridad entre múltiples hilos. En un contexto embebido, consideramos que las interrupciones se ejecutan en un hilo separado del código de la aplicación, por lo que las variables accedidas tanto por una interrupción como por el código principal deben ser Sync.</p>
<p>Para la mayoría de los tipos en Rust, ambos <em>traits</em> se derivan automáticamente por el compilador. Sin embargo, debido a que <code>CSCounter</code> contiene una <a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>, no es Sync, y por lo tanto no podríamos hacer un <code>static CSCounter</code>: las variables <code>static</code> <em>deben</em> ser Sync, ya que pueden ser accedidas por múltiples hilos.</p>
<p>Para indicar al compilador que nos hemos asegurado de que el <code>CSCounter</code> es seguro para compartir entre hilos, implementamos el rasgo Sync explícitamente. Al igual que con el uso anterior de secciones críticas, esto sólo es seguro en plataformas mononúcleo: con múltiples núcleos, tendrías que ir más lejos para garantizar la seguridad.</p>
<h2 id="mutexes"><a class="header" href="#mutexes">Mutexes</a></h2>
<p>Hemos creado una abstracción útil específica para nuestro problema de contadores, pero hay muchas abstracciones comunes utilizadas para la concurrencia.</p>
<p>Una de estas <em>primitivas de sincronización</em> es un mutex, abreviatura de exclusión mutua. Estas construcciones aseguran el acceso exclusivo a una variable, como nuestro contador. Un hilo puede intentar <em>bloquear</em> (o <em>adquirir</em>) el mutex, y o bien lo consigue inmediatamente, o se bloquea esperando a que se adquiera el bloqueo, o devuelve un error de que el mutex no se ha podido bloquear. Mientras ese hilo mantiene el bloqueo, se le concede acceso a los datos protegidos. Cuando el hilo termina, <em>desbloquea</em> (o <em>libera</em>) el mutex, permitiendo que otro hilo lo bloquee. En Rust, normalmente implementaríamos el desbloqueo usando el rasgo <a href="https://doc.rust-lang.org/core/ops/trait.Drop.html"><code>Drop</code></a> para asegurarnos de que siempre se libera cuando el mutex sale del ámbito.</p>
<p>Usar un mutex con manejadores de interrupciones puede ser complicado: normalmente no es aceptable que el manejador de interrupciones se bloquee, y sería especialmente desastroso que se bloqueara esperando a que el hilo principal liberara un bloqueo, ya que entonces nos <em>deadlock</em> (el hilo principal nunca liberará el bloqueo porque la ejecución permanece en el manejador de interrupciones). El deadlock no se considera inseguro: es posible incluso en Rust seguro.</p>
<p>Para evitar completamente este comportamiento, podríamos implementar un mutex que requiera una sección crítica para bloquearse, como en nuestro ejemplo del contador. Mientras la sección crítica dure lo mismo que el bloqueo, podemos estar seguros de que tenemos acceso exclusivo a la variable envuelta sin necesidad de seguir el estado de bloqueo/desbloqueo del mutex.</p>
<p>De hecho, ¡esto lo hace por nosotros la <em>crate</em> <code>cortex_m</code>! Podríamos haber escrito nuestro contador usándolo:</p>
<pre><code class="language-rust ignore">use core::cell::Cell;
use cortex_m::interrupt::Mutex;

static COUNTER: Mutex&lt;Cell&lt;u32&gt;&gt; = Mutex::new(Cell::new(0));

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            interrupt::free(|cs|
                COUNTER.borrow(cs).set(COUNTER.borrow(cs).get() + 1));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // We still need to enter a critical section here to satisfy the Mutex.
    interrupt::free(|cs| COUNTER.borrow(cs).set(0));
}</code></pre>
<p>Ahora estamos utilizando <a href="https://doc.rust-lang.org/core/cell/struct.Cell.html"><code>Cell</code></a>, que junto con su hermano <code>RefCell</code> se utiliza para proporcionar mutabilidad interior segura. Ya hemos visto <code>UnsafeCell</code> que es la capa inferior de mutabilidad interior en Rust: te permite obtener múltiples referencias mutables a su valor, pero sólo con código inseguro. Una <code>Cell</code> es como una <code>UnsafeCell</code> pero proporciona una interfaz segura: sólo permite tomar una copia del valor actual o reemplazarlo, no tomar una referencia, y como no es Sync, no puede ser compartida entre hilos. Estas restricciones hacen que su uso sea seguro, pero no podríamos usarlo directamente en una variable <code>static</code> ya que una <code>static</code> debe ser Sync.</p>
<p>¿Por qué funciona el ejemplo anterior? El <code>Mutex&lt;T&gt;</code> implementa Sync para cualquier <code>T</code> que sea Send - como una <code>Cell</code>. Puede hacer esto de forma segura porque sólo da acceso a su contenido durante una sección crítica. Por lo tanto, podemos obtener un contador seguro sin código inseguro.</p>
<p>Esto es genial para tipos simples como el <code>u32</code> de nuestro contador, pero ¿qué pasa con tipos más complejos que no son Copy? Un ejemplo extremadamente común en un contexto embebido es una estructura periférica, que generalmente no es Copy. Para eso, podemos recurrir a <code>RefCell</code>.</p>
<h2 id="compartiendo-periféricos"><a class="header" href="#compartiendo-periféricos">Compartiendo Periféricos</a></h2>
<p>Las <em>crates</em> de dispositivos generadas usando <code>svd2rust</code> y abstracciones similares proporcionan un acceso seguro a los periféricos al imponer que sólo una instancia de la estructura periférica puede existir a la vez. Esto garantiza la seguridad, pero dificulta el acceso a un periférico tanto desde el hilo principal como desde un manejador de interrupciones.</p>
<p>Para compartir de forma segura el acceso a los periféricos, podemos utilizar el <code>Mutex</code> que vimos antes. También necesitaremos usar <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code>RefCell</code></a>, que utiliza una comprobación en tiempo de ejecución para asegurar que sólo se da una referencia a un periférico cada vez. Esto tiene más sobrecarga que el simple <code>Cell</code>, pero ya que estamos dando referencias en lugar de copias, debemos estar seguros de que sólo existe una a la vez.</p>
<p>Por último, también tendremos que tener en cuenta la forma de mover el periférico a la variable compartida después de que se haya inicializado en el código principal. Para ello podemos utilizar el tipo <code>Option</code>, inicializado a <code>None</code> y posteriormente establecido a la instancia del periférico.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use cortex_m::interrupt::{self, Mutex};
use stm32f4::stm32f405;

static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    // Obtain the peripheral singletons and configure it.
    // This example is from an svd2rust-generated crate, but
    // most embedded device crates will be similar.
    let dp = stm32f405::Peripherals::take().unwrap();
    let gpioa = &amp;dp.GPIOA;

    // Some sort of configuration function.
    // Assume it sets PA0 to an input and PA1 to an output.
    configure_gpio(gpioa);

    // Store the GPIOA in the mutex, moving it.
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
    // We can no longer use `gpioa` or `dp.GPIOA`, and instead have to
    // access it via the mutex.

    // Be careful to enable the interrupt only after setting MY_GPIO:
    // otherwise the interrupt might fire while it still contains None,
    // and as-written (with `unwrap()`), it would panic.
    set_timer_1hz();
    let mut last_state = false;
    loop {
        // We'll now read state as a digital input, via the mutex
        let state = interrupt::free(|cs| {
            let gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        if state &amp;&amp; !last_state {
            // Set PA1 high if we've seen a rising edge on PA0.
            interrupt::free(|cs| {
                let gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // This time in the interrupt we'll just clear PA0.
    interrupt::free(|cs| {
        // We can use `unwrap()` because we know the interrupt wasn't enabled
        // until after MY_GPIO was set; otherwise we should handle the potential
        // for a None value.
        let gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}</code></pre>
<p>Es mucho para asimilar, así que vamos a desglosar las líneas importantes.</p>
<pre><code class="language-rust ignore">static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));</code></pre>
<p>Nuestra variable compartida es ahora un <code>Mutex</code> alrededor de una <code>RefCell</code> que contiene una <code>Option</code>. El <code>Mutex</code> asegura que sólo tenemos acceso durante una sección crítica, y por lo tanto hace que la variable sea Sync, a pesar de que una <code>RefCell</code> normal no sería Sync. La <code>RefCell</code> nos da mutabilidad interior con referencias, que necesitaremos para usar nuestro <code>GPIOA</code>. La <code>Option</code> nos permite inicializar esta variable a algo vacío, y sólo después realmente mover la variable. No podemos acceder al singleton periférico estáticamente, sólo en tiempo de ejecución, así que esto es necesario.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));</code></pre>
<p>Dentro de una sección crítica podemos llamar a <code>borrow()</code> en el mutex, que nos da una referencia a la <code>RefCell</code>. Luego llamamos a <code>replace()</code> para mover nuestro nuevo valor a la <code>RefCell</code>.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| {
    let gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});</code></pre>
<p>Por último, utilizamos <code>MY_GPIO</code> de forma segura y concurrente. La sección crítica evita que la interrupción se dispare como de costumbre, y nos permite tomar prestado el mutex. La <code>RefCell</code> nos da una <code>&amp;Option&lt;GPIOA&gt;</code>, y controla cuánto tiempo permanece prestada - una vez que la referencia sale del ámbito, la <code>RefCell</code> se actualiza para indicar que ya no está prestada.</p>
<p>Como no podemos mover el <code>GPIOA</code> fuera de <code>&amp;Option</code>, tenemos que convertirlo en un <code>&amp;Option&lt;&amp;GPIOA&gt;</code> con <code>as_ref()</code>, que finalmente podemos <code>unwrap()</code> para obtener el <code>&amp;GPIOA</code> que nos permite modificar el periférico.</p>
<p>Si necesitamos una referencia mutable a un recurso compartido, entonces debemos usar <code>borrow_mut</code> y <code>deref_mut</code> en su lugar. El siguiente código muestra un ejemplo utilizando el temporizador TIM2.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use core::ops::DerefMut;
use cortex_m::interrupt::{self, Mutex};
use cortex_m::asm::wfi;
use stm32f4::stm32f405;

static G_TIM: Mutex&lt;RefCell&lt;Option&lt;Timer&lt;stm32::TIM2&gt;&gt;&gt;&gt; =
	Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    let mut cp = cm::Peripherals::take().unwrap();
    let dp = stm32f405::Peripherals::take().unwrap();

    // Some sort of timer configuration function.
    // Assume it configures the TIM2 timer, its NVIC interrupt,
    // and finally starts the timer.
    let tim = configure_timer_interrupt(&amp;mut cp, dp);

    interrupt::free(|cs| {
        G_TIM.borrow(cs).replace(Some(tim));
    });

    loop {
        wfi();
    }
}

#[interrupt]
fn timer() {
    interrupt::free(|cs| {
        if let Some(ref mut tim)) =  G_TIM.borrow(cs).borrow_mut().deref_mut() {
            tim.start(1.hz());
        }
    });
}
</code></pre>
<p>¡Uf! Esto es seguro, pero también es un poco difícil de manejar. ¿Hay algo más que podamos hacer?</p>
<h2 id="rtic"><a class="header" href="#rtic">RTIC</a></h2>
<p>Una alternativa es el <a href="https://github.com/rtic-rs/cortex-m-rtic">RTIC framework</a>, abreviatura de Real Time Interrupt-driven Concurrency. Refuerza las prioridades estáticas y rastrea los accesos a variables <code>static mut</code> (&quot;recursos&quot;) para asegurar estáticamente que siempre se accede a los recursos compartidos de forma segura, sin requerir la sobrecarga de entrar siempre en secciones críticas y usar el conteo de referencias (como en <code>RefCell</code>). Esto tiene una serie de ventajas, como garantizar que no se produzcan bloqueos y ofrecer una sobrecarga de tiempo y memoria extremadamente baja.</p>
<p>El marco también incluye otras características como el paso de mensajes, que reduce la necesidad de un estado compartido explícito, y la capacidad de programar tareas para que se ejecuten en un momento dado, lo que puede utilizarse para implementar tareas periódicas. Consulta <a href="https://rtic.rs">la documentación</a> para obtener más información.</p>
<h2 id="sistemas-operativos-en-tiempo-real"><a class="header" href="#sistemas-operativos-en-tiempo-real">Sistemas operativos en tiempo real</a></h2>
<p>Otro modelo común para la concurrencia embebida es el sistema operativo en tiempo real (RTOS). Aunque actualmente están menos explorados en Rust, son ampliamente utilizados en el desarrollo embebido tradicional. Ejemplos de código abierto incluyen <a href="https://freertos.org/">FreeRTOS</a> y <a href="http://chibios.org/">ChibiOS</a>. Estos RTOSs proporcionan soporte para ejecutar múltiples hilos de aplicación que la CPU intercambia, ya sea cuando los hilos ceden el control (llamado multitarea cooperativa) o basado en un temporizador regular o interrupciones (multitarea preventiva). Los RTOS suelen proporcionar mutexes y otras primitivas de sincronización, y a menudo interoperan con funciones de hardware como los motores DMA.</p>
<p>En el momento de escribir esto, no hay muchos ejemplos de Rust RTOS a los que apuntar, pero es un área interesante así que ¡mira este espacio!</p>
<h2 id="múltiples-núcleos"><a class="header" href="#múltiples-núcleos">Múltiples núcleos</a></h2>
<p>Cada vez es más común tener dos o más núcleos en procesadores embebidos, lo que añade una capa extra de complejidad a la concurrencia. Todos los ejemplos que utilizan una sección crítica (incluyendo el <code>cortex_m::interrupt::Mutex</code>) asumen que el único otro hilo de ejecución es el hilo de interrupción, pero en un sistema multinúcleo eso ya no es cierto. En su lugar, necesitaremos primitivas de sincronización diseñadas para múltiples núcleos (también llamadas SMP, por multiprocesamiento simétrico).</p>
<p>Éstas suelen utilizar las instrucciones atómicas que hemos visto antes, ya que el sistema de procesamiento garantizará que la atomicidad se mantenga en todos los núcleos.</p>
<p>Cubrir estos temas en detalle está actualmente fuera del alcance de este libro, pero los patrones generales son los mismos que para el caso de un solo núcleo.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../portability/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../collections/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../portability/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../collections/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
