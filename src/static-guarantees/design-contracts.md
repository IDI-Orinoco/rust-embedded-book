# Contratos de diseño

En nuestro último capítulo, escribimos una interfaz que _no_ hacía cumplir los contratos de diseño. Echemos otro vistazo a nuestro registro de configuración GPIO imaginario:

|       Nombre | Número(s) de bit | Valor | Significado |                                                 Notas |
| -----------: | ---------------: | ----: | ----------: | ----------------------------------------------------: |
|       enable |                0 |     0 |    disabled |                                   Deshabilita el GPIO |
|              |                  |     1 |     enabled |                                      Habilita el GPIO |
|    direction |                1 |     0 |       input |                      Establece la dirección a Entrada |
|              |                  |     1 |      output |                       Establece la dirección a Salida |
|   input_mode |             2..3 |    00 |        hi-z |             Establece la entrada como alta impedancia |
|              |                  |    01 |    pull-low |                        El pin de entrada es pull-down |
|              |                  |    10 |   pull-high |                          El pin de entrada es pull-up |
|              |                  |    11 |         n/a |                        Estado Inválido. No establecer |
|  output_mode |                4 |     0 |     set-low |                      El pin de salida se lleva a bajo |
|              |                  |     1 |    set-high |                      El pin de salida se lleva a alto |
| input_status |                5 |     x |      in-val | 0 si la entrada es < 1.5v, 1 si la entrada es >= 1.5v |

Si, en cambio, verificamos el estado antes de hacer uso del hardware subyacente, haciendo cumplir nuestros contratos de diseño en tiempo de ejecución, podríamos escribir un código que se vea así:

```rust,ignore
/// GPIO interface
struct GpioConfig {
    /// GPIO Configuration structure generated by svd2rust
    periph: GPIO_CONFIG,
}

impl GpioConfig {
    pub fn set_enable(&mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&mut self, is_output: bool) -> Result<(), ()> {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to set direction
            return Err(());
        }

        self.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });

        Ok(())
    }

    pub fn set_input_mode(&mut self, variant: InputMode) -> Result<(), ()> {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to set input mode
            return Err(());
        }

        if self.periph.read().direction().bit_is_set() {
            // Direction must be input
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });

        Ok(())
    }

    pub fn set_output_status(&mut self, is_high: bool) -> Result<(), ()> {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to set output status
            return Err(());
        }

        if self.periph.read().direction().bit_is_clear() {
            // Direction must be output
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });

        Ok(())
    }

    pub fn get_input_status(&self) -> Result<bool, ()> {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to get status
            return Err(());
        }

        if self.periph.read().direction().bit_is_set() {
            // Direction must be input
            return Err(());
        }

        Ok(self.periph.read().input_status().bit_is_set())
    }
}
```

Debido a que necesitamos hacer cumplir las restricciones en el hardware, terminamos haciendo muchas comprobaciones en tiempo de ejecución, lo que desperdicia tiempo y recursos, y este código será mucho menos agradable de usar para el desarrollador.

## Tipo de estados

But what if instead, we used Rust's type system to enforce the state transition rules? Take this example:

```rust,ignore
/// GPIO interface
struct GpioConfig<ENABLED, DIRECTION, MODE> {
    /// GPIO Configuration structure generated by svd2rust
    periph: GPIO_CONFIG,
    enabled: ENABLED,
    direction: DIRECTION,
    mode: MODE,
}

// Type states for MODE in GpioConfig
struct Disabled;
struct Enabled;
struct Output;
struct Input;
struct PulledLow;
struct PulledHigh;
struct HighZ;
struct DontCare;

/// These functions may be used on any GPIO Pin
impl<EN, DIR, IN_MODE> GpioConfig<EN, DIR, IN_MODE> {
    pub fn into_disabled(self) -> GpioConfig<Disabled, DontCare, DontCare> {
        self.periph.modify(|_r, w| w.enable.disabled());
        GpioConfig {
            periph: self.periph,
            enabled: Disabled,
            direction: DontCare,
            mode: DontCare,
        }
    }

    pub fn into_enabled_input(self) -> GpioConfig<Enabled, Input, HighZ> {
        self.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.input()
             .input_mode.high_z()
        });
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_enabled_output(self) -> GpioConfig<Enabled, Output, DontCare> {
        self.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.output()
             .input_mode.set_high()
        });
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Output,
            mode: DontCare,
        }
    }
}

/// This function may be used on an Output Pin
impl GpioConfig<Enabled, Output, DontCare> {
    pub fn set_bit(&mut self, set_high: bool) {
        self.periph.modify(|_r, w| w.output_mode.set_bit(set_high));
    }
}

/// These methods may be used on any enabled input GPIO
impl<IN_MODE> GpioConfig<Enabled, Input, IN_MODE> {
    pub fn bit_is_set(&self) -> bool {
        self.periph.read().input_status.bit_is_set()
    }

    pub fn into_input_high_z(self) -> GpioConfig<Enabled, Input, HighZ> {
        self.periph.modify(|_r, w| w.input_mode().high_z());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_input_pull_down(self) -> GpioConfig<Enabled, Input, PulledLow> {
        self.periph.modify(|_r, w| w.input_mode().pull_low());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledLow,
        }
    }

    pub fn into_input_pull_up(self) -> GpioConfig<Enabled, Input, PulledHigh> {
        self.periph.modify(|_r, w| w.input_mode().pull_high());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledHigh,
        }
    }
}
```

Ahora veamos cómo se vería el código que usa esto:

```rust,ignore
/*
 * Example 1: Unconfigured to High-Z input
 */
let pin: GpioConfig<Disabled, _, _> = get_gpio();

// Can't do this, pin isn't enabled!
// pin.into_input_pull_down();

// Now turn the pin from unconfigured to a high-z input
let input_pin = pin.into_enabled_input();

// Read from the pin
let pin_state = input_pin.bit_is_set();

// Can't do this, input pins don't have this interface!
// input_pin.set_bit(true);

/*
 * Example 2: High-Z input to Pulled Low input
 */
let pulled_low = input_pin.into_input_pull_down();
let pin_state = pulled_low.bit_is_set();

/*
 * Example 3: Pulled Low input to Output, set high
 */
let output_pin = pulled_low.into_enabled_output();
output_pin.set_bit(true);

// Can't do this, output pins don't have this interface!
// output_pin.into_input_pull_down();
```

Esta es definitivamente una forma conveniente de almacenar el estado del pin, pero ¿por qué hacerlo de esta manera? ¿Por qué es esto mejor que almacenar el estado como un `enum` dentro de nuestra estructura `GpioConfig`?

## Tiempo de compilación Seguridad funcional

Debido a que estamos aplicando nuestras restricciones de diseño por completo en tiempo de compilación, esto no genera costos de tiempo de ejecución. Es imposible establecer un modo de salida cuando tienes un pin en un modo de entrada. En su lugar, debes recorrer los estados convirtiéndolos en un pin de salida y luego configurando el modo de salida. Debido a esto, no hay penalización de tiempo de ejecución por verificar el estado actual antes de ejecutar una función.

Además, debido a que estos estados son impuestos por el sistema de tipos, ya no hay espacio para errores por parte de los consumidores de esta interfaz. Si intentan realizar una transición de estado ilegal, ¡el código no se compilará!
