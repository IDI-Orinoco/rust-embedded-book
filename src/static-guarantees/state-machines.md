# Periféricos como Máquinas de Estado

Los periféricos de un microcontrolador se pueden considerar como un conjunto de máquinas de estado. Por ejemplo, la configuración de un [pin GPIO] simplificada podría representarse como el siguiente árbol de estados:

[pin gpio]: https://en.wikipedia.org/wiki/General-purpose_input/output

- Desactivado
- Activado
  - Configurado como Salida
    - Salida: Alto
    - Salida: Bajo
  - Configurado como Entrada
    - Entrada: Alta Impedancia
    - Entrada: Pull-down
    - Entrada: Pull-up

Si el periférico arranca en el modo `Deshabilitado`, para pasar al modo `Entrada: Alta Impedancia`, debemos realizar los siguientes pasos:

1. Deshabilitado
2. Habilitado
3. Configurado como Entrada
4. Entrada: Alta Impedancia

Si quisiéramos pasar de `Entrada: Alta Impedancia` a `Entrada: Pull-down`, debemos realizar los siguientes pasos:

1. Entrada: Alta Impedancia
2. Entrada: Pull-down

De igual forma, si queremos mover un pin GPIO de configurado como `Entrada: Pull-down` a `Salida: Alto`, debemos realizar los siguientes pasos:

1. Entrada: Pull-down
2. Configurado como Entrada
3. Configurado como Salida
4. Salida: Alto

## Representación de hardware

Por lo general, los estados enumerados anteriormente se establecen escribiendo valores en registros asignados a un periférico GPIO. Definamos un registro de configuración GPIO imaginario para ilustrar esto:

|       Nombre | Número(s) de bit | Valor | Significado |                                                 Notas |
| -----------: | ---------------: | ----: | ----------: | ----------------------------------------------------: |
|       enable |                0 |     0 |    disabled |                                   Deshabilita el GPIO |
|              |                  |     1 |     enabled |                                      Habilita el GPIO |
|    direction |                1 |     0 |       input |                     Establece la dirección en Entrada |
|              |                  |     1 |      output |                      Establece la dirección en Salida |
|   input_mode |             2..3 |    00 |        hi-z |             Establece la entrada como alta impedancia |
|              |                  |    01 |   pull-down |            El pin de entrada se establece a pull-down |
|              |                  |    10 |     pull-up |              El pin de entrada se establece a pull-up |
|              |                  |    11 |         n/a |                        Estado Inválido. No establecer |
|  output_mode |                4 |     0 |     set-low |                      El pin de salida se lleva a bajo |
|              |                  |     1 |    set-high |                      El pin de salida se lleva a alto |
| input_status |                5 |     x |      in-val | 0 si la entrada es < 1.5v, 1 si la entrada es >= 1.5v |

_Podríamos_ exponer la siguiente estructura en Rust para controlar este GPIO:

```rust,ignore
/// GPIO interface
struct GpioConfig {
    /// GPIO Configuration structure generated by svd2rust
    periph: GPIO_CONFIG,
}

impl GpioConfig {
    pub fn set_enable(&mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&mut self, is_output: bool) {
        self.periph.modify(|_r, w| {
            w.direction().set_bit(is_output)
        });
    }

    pub fn set_input_mode(&mut self, variant: InputMode) {
        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });
    }

    pub fn set_output_mode(&mut self, is_high: bool) {
        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });
    }

    pub fn get_input_status(&self) -> bool {
        self.periph.read().input_status().bit_is_set()
    }
}
```

Sin embargo, esto nos permitiría modificar ciertos registros que no tienen sentido. Por ejemplo, ¿qué sucede si configuramos el campo `output_mode` cuando nuestro GPIO está configurado como entrada?

En general, el uso de esta estructura nos permitiría alcanzar estados no definidos por nuestra máquina de estado anterior: p.e. una salida con un pull-down o una entrada establecida a nivel alto. Para algunos hardware, esto puede no importar. ¡En otro hardware, podría causar un comportamiento inesperado o indefinido!

Aunque esta interfaz es conveniente para escribir, no hace cumplir los contratos de diseño establecidos por nuestra implementación de hardware.
