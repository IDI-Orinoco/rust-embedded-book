<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Consejos para desarrolladores de C embebido - El Libro de Rust Embebido</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introducción</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hardware.html"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="../intro/no-std.html"><strong aria-hidden="true">1.2.</strong> no_std</a></li><li class="chapter-item expanded "><a href="../intro/tooling.html"><strong aria-hidden="true">1.3.</strong> Herramientas</a></li><li class="chapter-item expanded "><a href="../intro/install.html"><strong aria-hidden="true">1.4.</strong> Instalación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/install/linux.html"><strong aria-hidden="true">1.4.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../intro/install/macos.html"><strong aria-hidden="true">1.4.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="../intro/install/windows.html"><strong aria-hidden="true">1.4.3.</strong> Windows</a></li><li class="chapter-item expanded "><a href="../intro/install/verify.html"><strong aria-hidden="true">1.4.4.</strong> Verificar Instalación</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">2.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/qemu.html"><strong aria-hidden="true">2.1.</strong> QEMU</a></li><li class="chapter-item expanded "><a href="../start/hardware.html"><strong aria-hidden="true">2.2.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="../start/registers.html"><strong aria-hidden="true">2.3.</strong> Registros mapeados en memoria</a></li><li class="chapter-item expanded "><a href="../start/semihosting.html"><strong aria-hidden="true">2.4.</strong> Semihosting</a></li><li class="chapter-item expanded "><a href="../start/panicking.html"><strong aria-hidden="true">2.5.</strong> Pánico</a></li><li class="chapter-item expanded "><a href="../start/exceptions.html"><strong aria-hidden="true">2.6.</strong> Excepciones</a></li><li class="chapter-item expanded "><a href="../start/interrupts.html"><strong aria-hidden="true">2.7.</strong> Interrupciones</a></li><li class="chapter-item expanded "><a href="../start/io.html"><strong aria-hidden="true">2.8.</strong> E/S</a></li></ol></li><li class="chapter-item expanded "><a href="../peripherals/index.html"><strong aria-hidden="true">3.</strong> Periféricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../peripherals/a-first-attempt.html"><strong aria-hidden="true">3.1.</strong> Un primer intento en Rust</a></li><li class="chapter-item expanded "><a href="../peripherals/borrowck.html"><strong aria-hidden="true">3.2.</strong> El comprobador de préstamos</a></li><li class="chapter-item expanded "><a href="../peripherals/singletons.html"><strong aria-hidden="true">3.3.</strong> Singletons</a></li></ol></li><li class="chapter-item expanded "><a href="../static-guarantees/index.html"><strong aria-hidden="true">4.</strong> Garantías estáticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../static-guarantees/typestate-programming.html"><strong aria-hidden="true">4.1.</strong> Programación por Typestate</a></li><li class="chapter-item expanded "><a href="../static-guarantees/state-machines.html"><strong aria-hidden="true">4.2.</strong> Periféricos como máquinas de estado</a></li><li class="chapter-item expanded "><a href="../static-guarantees/design-contracts.html"><strong aria-hidden="true">4.3.</strong> Contratos de diseño</a></li><li class="chapter-item expanded "><a href="../static-guarantees/zero-cost-abstractions.html"><strong aria-hidden="true">4.4.</strong> Abstracciones de costo cero</a></li></ol></li><li class="chapter-item expanded "><a href="../portability/index.html"><strong aria-hidden="true">5.</strong> Portabilidad</a></li><li class="chapter-item expanded "><a href="../concurrency/index.html"><strong aria-hidden="true">6.</strong> Concurrencia</a></li><li class="chapter-item expanded "><a href="../collections/index.html"><strong aria-hidden="true">7.</strong> Colecciones</a></li><li class="chapter-item expanded "><a href="../design-patterns/index.html"><strong aria-hidden="true">8.</strong> Design Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/index.html"><strong aria-hidden="true">8.1.</strong> HALs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/checklist.html"><strong aria-hidden="true">8.1.1.</strong> Lista de chequeo</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/naming.html"><strong aria-hidden="true">8.1.2.</strong> Nomenclatura</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/interoperability.html"><strong aria-hidden="true">8.1.3.</strong> Interoperabilidad</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/predictability.html"><strong aria-hidden="true">8.1.4.</strong> Previsibilidad</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/gpio.html"><strong aria-hidden="true">8.1.5.</strong> GPIO</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../c-tips/index.html" class="active"><strong aria-hidden="true">9.</strong> Consejos para desarrolladores de C embebido</a></li><li class="chapter-item expanded "><a href="../interoperability/index.html"><strong aria-hidden="true">10.</strong> Interoperabilidad</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interoperability/c-with-rust.html"><strong aria-hidden="true">10.1.</strong> Un poco de C con tu Rust</a></li><li class="chapter-item expanded "><a href="../interoperability/rust-with-c.html"><strong aria-hidden="true">10.2.</strong> Un poco de Rust con tu C</a></li></ol></li><li class="chapter-item expanded "><a href="../unsorted/index.html"><strong aria-hidden="true">11.</strong> Temas sin clasificar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsorted/speed-vs-size.html"><strong aria-hidden="true">11.1.</strong> Optimizaciones: El equilibrio entre velocidad y tamaño</a></li><li class="chapter-item expanded "><a href="../unsorted/math.html"><strong aria-hidden="true">11.2.</strong> Realización de funciones matemáticas</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../appendix/glossary.html">Apéndice A: Glosario</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Libro de Rust Embebido</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/idio/rust-embedded-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="consejos-para-desarrolladores-de-c-embebido"><a class="header" href="#consejos-para-desarrolladores-de-c-embebido">Consejos para desarrolladores de C embebido</a></h1>
<p>Este capítulo recoge una serie de consejos que pueden ser útiles para desarrolladores experimentados en C embebido que quieran empezar a escribir Rust. Destacará especialmente cómo las cosas a las que ya podrías estar acostumbrado en C son diferentes en Rust.</p>
<h2 id="preprocesador"><a class="header" href="#preprocesador">Preprocesador</a></h2>
<p>En C embebido es muy común usar el preprocesador para una variedad de propósitos, tales como:</p>
<ul>
<li>Selección en tiempo de compilación de bloques de código con <code>#ifdef</code>.</li>
<li>Cálculos y tamaños de matrices en tiempo de compilación</li>
<li>Macros para simplificar patrones comunes (para evitar el costo de las llamadas a funciones)</li>
</ul>
<p>En Rust no hay preprocesador, por lo que muchos de estos casos de uso se abordan de manera diferente. En el resto de esta sección cubrimos varias alternativas al uso del preprocesador.</p>
<h3 id="selección-de-código-en-tiempo-de-compilación"><a class="header" href="#selección-de-código-en-tiempo-de-compilación">Selección de Código en Tiempo de Compilación</a></h3>
<p>Lo más parecido a <code>#ifdef ... #endif</code> en Rust son las <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">prestaciones de Cargo</a>. Éstas son un poco más formales que el preprocesador de C: todas las prestaciones posibles se listan explícitamente por <em>crate</em>, y sólo pueden estar activadas o desactivadas. Las prestaciones se activan cuando listas una <em>crate</em> como dependencia, y son aditivas: si cualquier <em>crate</em> en tu árbol de dependencias activa una prestación para otra <em>crate</em>, esa prestación se activará para todos los usuarios de esa <em>crate</em>.</p>
<p>Por ejemplo, puedes tener una <em>crate</em> que proporcione una biblioteca de primitivas de procesamiento de señales. Cada una de ellas puede requerir un tiempo extra de compilación o declarar una gran tabla de constantes que te gustaría evitar. Podrías declarar una función de Cargo para cada componente en tu <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
FIR = []
IIR = []
</code></pre>
<p>A continuación, en tu código, utiliza <code>#[cfg(feature=&quot;FIR&quot;)]</code> para controlar lo que se incluye.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// In your top-level lib.rs

#[cfg(feature=&quot;FIR&quot;)]
pub mod fir;

#[cfg(feature=&quot;IIR&quot;)]
pub mod iir;
<span class="boring">}</span></code></pre></pre>
<p>De forma similar, puede incluir bloques de código sólo si una prestación <em>no</em> está habilitada, o si cualquier combinación de prestaciones está o no está habilitada.</p>
<p>Además, Rust proporciona una serie de condiciones de configuración automática que puedes utilizar, como <code>target_arch</code> para seleccionar código diferente basado en la arquitectura. Para más detalles sobre el soporte de compilación condicional, consulta el capítulo <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">compilación condicional</a> de la referencia de Rust.</p>
<p>La compilación condicional sólo se aplicará a la siguiente sentencia o bloque. Si un bloque no puede ser utilizado en el ámbito actual, entonces el atributo <code>cfg</code> tendrá que ser utilizado varias veces. Vale la pena señalar que la mayoría de las veces es mejor simplemente incluir todo el código y permitir que el compilador elimine el código muerto al optimizar: es más simple para ti y tus usuarios, y en general el compilador hará un buen trabajo eliminando el código no utilizado.</p>
<h3 id="computación-y-tamaños-en-tiempo-de-compilación"><a class="header" href="#computación-y-tamaños-en-tiempo-de-compilación">Computación y Tamaños en Tiempo de Compilación</a></h3>
<p>Rust soporta <code>const fn</code>, funciones que se garantiza que son evaluables en tiempo de compilación y por lo tanto se pueden utilizar cuando se requieren constantes, como en el tamaño de las matrices. Esto puede utilizarse junto con las funciones mencionadas anteriormente, por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn array_size() -&gt; usize {
    #[cfg(feature=&quot;use_more_ram&quot;)]
    { 1024 }
    #[cfg(not(feature=&quot;use_more_ram&quot;))]
    { 128 }
}

static BUF: [u32; array_size()] = [0u32; array_size()];
<span class="boring">}</span></code></pre></pre>
<p>Estos son nuevos para Rust estable a partir de 1.31, por lo que la documentación es todavía escasa. La funcionalidad disponible para <code>const fn</code> también es muy limitada en el momento de escribir esto; en futuras versiones de Rust se espera ampliar lo que se permite en un <code>const fn</code>.</p>
<h3 id="macros"><a class="header" href="#macros">Macros</a></h3>
<p>Rust proporciona un <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">sistema de macros</a> extremadamente potente. Mientras que el preprocesador de C opera casi directamente sobre el texto de tu código fuente, el sistema de macros de Rust opera a un nivel superior. Hay dos variedades de macros en Rust: <em>macros a través de ejemplo</em> y <em>macros procedimentales</em>. Las primeras son más simples y comunes; se parecen a las llamadas a funciones y pueden expandirse a una expresión, declaración, elemento o patrón completo. Las macros procedimentales son más complejas pero permiten adiciones extremadamente potentes al lenguaje Rust: pueden transformar sintaxis arbitraria de Rust en nueva sintaxis de Rust.</p>
<p>En general, donde podría haber utilizado una macro del preprocesador de C, probablemente quiera ver si una macro por ejemplo puede hacer el trabajo en su lugar. Pueden ser definidas en su <em>crate</em> y fácilmente usadas por su propio <em>crate</em> o exportadas para otros usuarios. Tenga en cuenta que, dado que deben expandirse a expresiones, sentencias, elementos o patrones completos, algunos casos de uso de macros del preprocesador de C no funcionarán, por ejemplo, una macro que se expanda a parte del nombre de una variable o a un conjunto incompleto de elementos de una lista.</p>
<p>Al igual que ocurre con las funciones de Cargo, conviene plantearse si se necesita la macro. En muchos casos, una función regular es más fácil de entender y será <em>inline</em> en el mismo código que una macro. Los <a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">atributos</a> <code>#[inline]</code> e <code>#[inline(always)]</code> ofrecen un mayor control sobre este proceso, aunque también en este caso hay que tener cuidado: el compilador alineará automáticamente funciones de la misma <em>crate</em> cuando sea necesario, por lo que forzarlo a hacerlo de forma inadecuada podría reducir el rendimiento.</p>
<p>Explicar todo el sistema de macros de Rust está fuera del alcance de esta página de consejos, así que te animamos a consultar la documentación de Rust para más detalles.</p>
<h2 id="sistema-de-construcción"><a class="header" href="#sistema-de-construcción">Sistema de construcción</a></h2>
<p>La mayoría de los <em>crates</em> de Rust se construyen usando Cargo (aunque no es obligatorio). Esto resuelve muchos problemas difíciles con los sistemas de construcción tradicionales. Sin embargo, es posible que desee personalizar el proceso de construcción. Cargo proporciona los <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">scripts <code>build.rs</code></a> para este propósito. Se trata de scripts de Rust que pueden interactuar con el sistema de compilación de Cargo según sea necesario.</p>
<p>Los casos de uso comunes para los scripts de compilación incluyen:</p>
<ul>
<li>proporcionar información en tiempo de compilación, por ejemplo incrustando estáticamente la fecha de compilación o el hash de commit de Git en el ejecutable</li>
<li>generar secuencias de comandos del enlazador en tiempo de compilación en función de las prestaciones seleccionadas u otra lógica</li>
<li>modificar la configuración de compilación de Cargo</li>
<li>añadir bibliotecas estáticas adicionales con las que enlazar</li>
</ul>
<p>Actualmente no hay soporte para scripts posteriores a la compilación, que tradicionalmente se han utilizado para tareas como la generación automática de binarios a partir de los objetos de compilación o la impresión de información de compilación.</p>
<h3 id="compilación-cruzada"><a class="header" href="#compilación-cruzada">Compilación cruzada</a></h3>
<p>El uso de Cargo como sistema de compilación también simplifica la compilación cruzada. En la mayoría de los casos basta con decirle a Cargo <code>--target thumbv6m-none-eabi</code> y encontrar un ejecutable adecuado en <code>target/thumbv6m-none-eabi/debug/myapp</code>.</p>
<p>Para plataformas no soportadas nativamente por Rust, necesitarás compilar <code>libcore</code> para ese objetivo por ti mismo. En tales plataformas, <a href="https://github.com/japaric/xargo">Xargo</a> puede ser utilizado como un sustituto de Cargo que automáticamente construye <code>libcore</code> para ti.</p>
<h2 id="iteradores-vs-acceso-a-matrices"><a class="header" href="#iteradores-vs-acceso-a-matrices">Iteradores vs Acceso a Matrices</a></h2>
<p>En C probablemente estés acostumbrado a acceder a arrays directamente por su índice:</p>
<pre><code class="language-c">int16_t arr[16];
int i;
for(i=0; i&lt;sizeof(arr)/sizeof(arr[0]); i++) {
    process(arr[i]);
}
</code></pre>
<p>En Rust esto es un anti-patrón: el acceso indexado puede ser más lento (ya que necesita ser comprobado) y puede impedir varias optimizaciones del compilador. Esta es una distinción importante y vale la pena repetirla: Rust comprobará los accesos fuera de los límites en la indexación manual de arrays para garantizar la seguridad de la memoria, mientras que C indexará alegremente fuera del array.</p>
<p>En su lugar, usa iteradores:</p>
<pre><code class="language-rust ignore">let arr = [0u16; 16];
for element in arr.iter() {
    process(*element);
}</code></pre>
<p>Los iteradores proporcionan una potente gama de funcionalidades que tendrías que implementar manualmente en C, como encadenar, comprimir, enumerar, encontrar el mínimo o el máximo, sumar, y más. Los métodos de los iteradores también pueden encadenarse, lo que proporciona un código de procesamiento de datos muy legible.</p>
<p>Consulte <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iteradores en el libro</a> y <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Documentación de los Iteradores</a> para obtener más información.</p>
<h2 id="referencias-vs-punteros"><a class="header" href="#referencias-vs-punteros">Referencias vs Punteros</a></h2>
<p>En Rust, los punteros (llamados punteros crudos (<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"><em>raw pointers</em></a>)) existen pero sólo se usan en circunstancias específicas, ya que desreferenciarlos siempre se considera inseguro (<code>unsafe</code>) -- Rust no puede proporcionar sus garantías habituales sobre lo que puede haber detrás del puntero.</p>
<p>En la mayoría de los casos, utilizamos <em>references</em>, indicadas por el símbolo <code>&amp;</code>, o <em>mutable references</em>, indicadas por <code>&amp;mut</code>. Las referencias se comportan de manera similar a los punteros, en el sentido de que pueden ser desreferenciadas para acceder a los valores subyacentes, pero son una parte clave del sistema de propiedad de Rust: Rust hará cumplir estrictamente que sólo se puede tener una referencia mutable <em>o</em> múltiples referencias no mutables al mismo valor en un momento dado.</p>
<p>En la práctica, esto significa que tienes que ser más cuidadoso sobre si necesitas acceso mutable a los datos: mientras que en C el valor por defecto es mutable y debes ser explícito sobre <code>const</code>, en Rust ocurre lo contrario.</p>
<p>Una situación en la que todavía se pueden utilizar <em>punteros crudos</em> es interactuando directamente con el hardware (por ejemplo, escribiendo un puntero a un buffer en un registro periférico DMA), y también se utilizan <em>tras bastidores</em> en todas las <em>crates</em> de acceso periférico para permitir la lectura y escritura de registros mapeados en memoria.</p>
<h2 id="acceso-volátil"><a class="header" href="#acceso-volátil">Acceso Volátil</a></h2>
<p>En C, las variables individuales pueden ser marcadas como <code>volatile</code>, indicando al compilador que el valor de la variable puede cambiar entre accesos. Las variables volátiles se usan comúnmente en un contexto embebido para registros mapeados en memoria.</p>
<p>En Rust, en lugar de marcar una variable como <code>volatile</code>, usamos métodos específicos para realizar accesos volátiles: <a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>core::ptr::read_volatile</code></a> y <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>core::ptr::write_volatile</code></a>. Estos métodos toman un <code>*const T</code> o un <code>*mut T</code> (<em>raw pointers</em>, como se ha comentado anteriormente) y realizan una lectura o escritura volátil.</p>
<p>Por ejemplo, en C podrías escribir</p>
<pre><code class="language-c">volatile bool signalled = false;

void ISR() {
    // Señal de que se ha producido la interrupción
    signalled = true;
}

void driver() {
    while(true) {
        // Dormir hasta la señal
        while(!signalled) { WFI(); }
        // Resetear la bandera de la señal
        signalled = false;
        // Realizar alguna tarea que estaba a la espera de la interrupción
        run_task();
    }
}
</code></pre>
<p>El equivalente en Rust usaría métodos volátiles en cada acceso:</p>
<pre><code class="language-rust ignore">static mut SIGNALLED: bool = false;

#[interrupt]
fn ISR() {
    // Señal de que se ha producido la interrupción
    // (En condiciones reales, debes considerar una primitiva de alto nivel,
    //  tal como un tipo atómico (atomic type)).
    unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, true) };
}

fn driver() {
    loop {
        // Dormir hasta la señal
        while unsafe { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
        // Resetear la bandera de la señal
        unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, false) };
        // Realizar alguna tarea que estaba a la espera de la interrupción
        run_task();
    }
}</code></pre>
<p>Vale la pena notar algunas cosas en el ejemplo de código:</p>
<ul>
<li>Podemos pasar <code>&amp;mut SIGNALLED</code> a la función que requiere <code>*mut T</code>, ya que <code>&amp;mut T</code> se convierte automáticamente en <code>*mut T</code> (y lo mismo para <code>*const T</code>)</li>
<li>Necesitamos bloques <code>unsafe</code> para los métodos <code>read_volatile</code>/<code>write_volatile</code>, ya que son funciones <code>unsafe</code>. Es responsabilidad del programador garantizar un uso seguro: consulte la documentación de los métodos para más detalles.</li>
</ul>
<p>Es raro que necesites estas funciones directamente en tu código, ya que normalmente se encargarán de ellas las bibliotecas de alto nivel. Para los periféricos mapeados en memoria, las <em>crates</em> de acceso a periféricos implementarán el acceso volátil automáticamente, mientras que para las primitivas de concurrencia hay mejores abstracciones disponibles (ver el <a href="../concurrency/index.html">capítulo de concurrencia</a>).</p>
<h2 id="tipos-empaquetados-y-alineados"><a class="header" href="#tipos-empaquetados-y-alineados">Tipos empaquetados y alineados</a></h2>
<p>En C embebido es común decirle al compilador que una variable debe tener una cierta alineación o que una estructura debe estar empaquetada en lugar de alineada, normalmente para cumplir requisitos específicos de hardware o protocolo.</p>
<p>En Rust esto se controla mediante el atributo <code>repr</code> de una estructura o unión. La representación por defecto no ofrece garantías de disposición, por lo que no debe utilizarse para código que interopera con hardware o C. El compilador puede reordenar los miembros de la estructura o insertar relleno y el comportamiento puede cambiar con futuras versiones de Rust.</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2
// Nota que el orden se cambió a x, z, y para mejorar el empaquetado.</code></pre></pre>
<p>Para asegurar diseños interoperables con C, use <code>repr(C)</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64
// El orden se preserva y la disposición no cambiará en el tiempo.
// `z` es alineado a dos bytes por lo que un byte de relleno existe entre `y` y `z`.</code></pre></pre>
<p>Para asegurar una representación empaquetada, use <code>repr(packed)</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(packed)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    // La referencias siempre deben estar alineadas, por lo tanto para revisar
    // las direcciones de los campos de las estructuras, usamos `std::ptr::addr_of!()`
    // para obtener un puntero crudo en lugar de sólo imprimir `&amp;v.x`.
    let px = std::ptr::addr_of!(v.x);
    let py = std::ptr::addr_of!(v.y);
    let pz = std::ptr::addr_of!(v.z);
    println!(&quot;{:p} {:p} {:p}&quot;, px, py, pz);
}

// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493
// No se ha insertado relleno entre `y` y `z`, por lo tanto, ahora `z` está desalineado.</code></pre></pre>
<p>Tenga en cuenta que el uso de <code>repr(packed)</code> también establece la alineación del tipo a <code>1</code>.</p>
<p>Finalmente, para especificar una alineación concreta, usa <code>repr(align(n))</code>, donde <code>n</code> es el número de bytes a alinear (y debe ser una potencia de dos):</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
#[repr(align(4096))]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    let u = Foo { x: 0, y: 0, z: 0 };
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z);
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;u.x, &amp;u.y, &amp;u.z);
}

// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004
// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004
// Las dos instancias `u` y `v` han sido colocadas en alineamientos de 4096 bytes,
// evidenciado por el `000` al final de sus direcciones.</code></pre></pre>
<p>Observe que podemos combinar <code>repr(C)</code> con <code>repr(align(n))</code> para obtener una disposición alineada y compatible con C. No es permisible combinar <code>repr(align(n))</code> con <code>repr(packed)</code>, ya que <code>repr(packed)</code> establece la alineación a <code>1</code>. Tampoco está permitido que un tipo <code>repr(packed)</code> contenga un tipo <code>repr(align(n))</code>.</p>
<p>Para más detalles sobre la disposición de tipos, consulta el capítulo <a href="https://doc.rust-lang.org/reference/type-layout.html">disposición de tipos</a> de la Referencia de Rust.</p>
<h2 id="otros-recursos"><a class="header" href="#otros-recursos">Otros Recursos</a></h2>
<ul>
<li>En este libro:
<ul>
<li><a href="../interoperability/c-with-rust.html">Un poco de C con tu Rust</a></li>
<li><a href="../interoperability/rust-with-c.html">Un poco de Rust con tu C</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">Preguntas frecuentes sobre Rust embebido</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">Punteros Rust para programadores C</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">Usé punteros, ¿y ahora qué?</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../design-patterns/hal/gpio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../interoperability/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../design-patterns/hal/gpio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../interoperability/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
