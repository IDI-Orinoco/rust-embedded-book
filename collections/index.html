<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Colecciones - El Libro de Rust Embebido</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introducción</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hardware.html"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="../intro/no-std.html"><strong aria-hidden="true">1.2.</strong> no_std</a></li><li class="chapter-item expanded "><a href="../intro/tooling.html"><strong aria-hidden="true">1.3.</strong> Herramientas</a></li><li class="chapter-item expanded "><a href="../intro/install.html"><strong aria-hidden="true">1.4.</strong> Instalación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/install/linux.html"><strong aria-hidden="true">1.4.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../intro/install/macos.html"><strong aria-hidden="true">1.4.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="../intro/install/windows.html"><strong aria-hidden="true">1.4.3.</strong> Windows</a></li><li class="chapter-item expanded "><a href="../intro/install/verify.html"><strong aria-hidden="true">1.4.4.</strong> Verificar Instalación</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">2.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/qemu.html"><strong aria-hidden="true">2.1.</strong> QEMU</a></li><li class="chapter-item expanded "><a href="../start/hardware.html"><strong aria-hidden="true">2.2.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="../start/registers.html"><strong aria-hidden="true">2.3.</strong> Registros mapeados en memoria</a></li><li class="chapter-item expanded "><a href="../start/semihosting.html"><strong aria-hidden="true">2.4.</strong> Semihosting</a></li><li class="chapter-item expanded "><a href="../start/panicking.html"><strong aria-hidden="true">2.5.</strong> Pánico</a></li><li class="chapter-item expanded "><a href="../start/exceptions.html"><strong aria-hidden="true">2.6.</strong> Excepciones</a></li><li class="chapter-item expanded "><a href="../start/interrupts.html"><strong aria-hidden="true">2.7.</strong> Interrupciones</a></li><li class="chapter-item expanded "><a href="../start/io.html"><strong aria-hidden="true">2.8.</strong> E/S</a></li></ol></li><li class="chapter-item expanded "><a href="../peripherals/index.html"><strong aria-hidden="true">3.</strong> Periféricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../peripherals/a-first-attempt.html"><strong aria-hidden="true">3.1.</strong> Un primer intento en Rust</a></li><li class="chapter-item expanded "><a href="../peripherals/borrowck.html"><strong aria-hidden="true">3.2.</strong> El comprobador de préstamos</a></li><li class="chapter-item expanded "><a href="../peripherals/singletons.html"><strong aria-hidden="true">3.3.</strong> Singletons</a></li></ol></li><li class="chapter-item expanded "><a href="../static-guarantees/index.html"><strong aria-hidden="true">4.</strong> Garantías estáticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../static-guarantees/typestate-programming.html"><strong aria-hidden="true">4.1.</strong> Programación por Typestate</a></li><li class="chapter-item expanded "><a href="../static-guarantees/state-machines.html"><strong aria-hidden="true">4.2.</strong> Periféricos como máquinas de estado</a></li><li class="chapter-item expanded "><a href="../static-guarantees/design-contracts.html"><strong aria-hidden="true">4.3.</strong> Contratos de diseño</a></li><li class="chapter-item expanded "><a href="../static-guarantees/zero-cost-abstractions.html"><strong aria-hidden="true">4.4.</strong> Abstracciones de costo cero</a></li></ol></li><li class="chapter-item expanded "><a href="../portability/index.html"><strong aria-hidden="true">5.</strong> Portabilidad</a></li><li class="chapter-item expanded "><a href="../concurrency/index.html"><strong aria-hidden="true">6.</strong> Concurrencia</a></li><li class="chapter-item expanded "><a href="../collections/index.html" class="active"><strong aria-hidden="true">7.</strong> Colecciones</a></li><li class="chapter-item expanded "><a href="../design-patterns/index.html"><strong aria-hidden="true">8.</strong> Design Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/index.html"><strong aria-hidden="true">8.1.</strong> HALs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/checklist.html"><strong aria-hidden="true">8.1.1.</strong> Lista de chequeo</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/naming.html"><strong aria-hidden="true">8.1.2.</strong> Nomenclatura</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/interoperability.html"><strong aria-hidden="true">8.1.3.</strong> Interoperabilidad</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/predictability.html"><strong aria-hidden="true">8.1.4.</strong> Previsibilidad</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/gpio.html"><strong aria-hidden="true">8.1.5.</strong> GPIO</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../c-tips/index.html"><strong aria-hidden="true">9.</strong> Consejos para desarrolladores de C embebido</a></li><li class="chapter-item expanded "><a href="../interoperability/index.html"><strong aria-hidden="true">10.</strong> Interoperabilidad</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interoperability/c-with-rust.html"><strong aria-hidden="true">10.1.</strong> Un poco de C con tu Rust</a></li><li class="chapter-item expanded "><a href="../interoperability/rust-with-c.html"><strong aria-hidden="true">10.2.</strong> Un poco de Rust con tu C</a></li></ol></li><li class="chapter-item expanded "><a href="../unsorted/index.html"><strong aria-hidden="true">11.</strong> Temas sin clasificar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsorted/speed-vs-size.html"><strong aria-hidden="true">11.1.</strong> Optimizaciones: El equilibrio entre velocidad y tamaño</a></li><li class="chapter-item expanded "><a href="../unsorted/math.html"><strong aria-hidden="true">11.2.</strong> Realización de funciones matemáticas</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../appendix/glossary.html">Apéndice A: Glosario</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Libro de Rust Embebido</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/idio/rust-embedded-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="colecciones"><a class="header" href="#colecciones">Colecciones</a></h1>
<p>Eventualmente querrás usar estructuras de datos dinámicas (también conocidas como colecciones) en tu programa. <code>std</code> proporciona un conjunto de colecciones comunes: <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>, etc. Todas las colecciones implementadas en <code>std</code> utilizan un asignador global de memoria dinámica (también conocido como heap).</p>
<p>Como <code>core</code> está, por definición, libre de asignaciones de memoria, estas implementaciones no están disponibles allí, pero se pueden encontrar en la <em>crate</em> <code>alloc</code> que viene con el compilador.</p>
<p>Si necesitas colecciones, una implementación asignada a heap no es tu única opción. También puedes usar colecciones de <em>capacidad fija</em>; una de estas implementaciones se encuentra en la <em>crate</em> <a href="https://crates.io/crates/heapless"><code>heapless</code></a>.</p>
<p>En esta sección, exploraremos y compararemos estas dos implementaciones.</p>
<h2 id="usando-alloc"><a class="header" href="#usando-alloc">Usando <code>alloc</code></a></h2>
<p>La <em>crate</em> <code>alloc</code> viene con la distribución estándar de Rust. Para importar la <em>crate</em> puedes <code>usarla</code> directamente <em>sin</em> declararla como dependencia en tu archivo <code>Cargo.toml</code>.</p>
<pre><code class="language-rust ignore">#![feature(alloc)]

extern crate alloc;

use alloc::vec::Vec;</code></pre>
<p>Para poder utilizar cualquier colección primero tendrás que utilizar el atributo <code>global_allocator</code> para declarar el asignador global que utilizará tu programa. Es necesario que el asignador que selecciones implemente el <em>trait</em> <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>.</p>
<p>Para completar y mantener esta sección lo más autocontenida posible, implementaremos un simple asignador de punteros y lo usaremos como asignador global. Sin embargo, te sugerimos encarecidamente que utilices un asignador probado en batalla que esté en crates.io en tu programa en lugar de este asignador.</p>
<pre><code class="language-rust ignore">// Bump pointer allocator implementation

use core::alloc::{GlobalAlloc, Layout};
use core::cell::UnsafeCell;
use core::ptr;

use cortex_m::interrupt;

// Bump pointer allocator for *single* core systems
struct BumpPointerAlloc {
    head: UnsafeCell&lt;usize&gt;,
    end: usize,
}

unsafe impl Sync for BumpPointerAlloc {}

unsafe impl GlobalAlloc for BumpPointerAlloc {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        // `interrupt::free` is a critical section that makes our allocator safe
        // to use from within interrupts
        interrupt::free(|_| {
            let head = self.head.get();
            let size = layout.size();
            let align = layout.align();
            let align_mask = !(align - 1);

            // move start up to the next alignment boundary
            let start = (*head + align - 1) &amp; align_mask;

            if start + size &gt; self.end {
                // a null pointer signal an Out Of Memory condition
                ptr::null_mut()
            } else {
                *head = start + size;
                start as *mut u8
            }
        })
    }

    unsafe fn dealloc(&amp;self, _: *mut u8, _: Layout) {
        // this allocator never deallocates memory
    }
}

// Declaration of the global memory allocator
// NOTE the user must ensure that the memory region `[0x2000_0100, 0x2000_0200]`
// is not used by other parts of the program
#[global_allocator]
static HEAP: BumpPointerAlloc = BumpPointerAlloc {
    head: UnsafeCell::new(0x2000_0100),
    end: 0x2000_0200,
};</code></pre>
<p>Además de seleccionar un asignador global, el usuario también tendrá que definir cómo se gestionan los errores de falta de memoria (OOM) usando el atributo <em>unstable</em> <code>alloc_error_handler</code>.</p>
<pre><code class="language-rust ignore">#![feature(alloc_error_handler)]

use cortex_m::asm;

#[alloc_error_handler]
fn on_oom(_layout: Layout) -&gt; ! {
    asm::bkpt();

    loop {}
}</code></pre>
<p>Una vez que todo esto está en su lugar, el usuario puede finalmente utilizar las colecciones en <code>alloc</code>.</p>
<pre><code class="language-rust ignore">#[entry]
fn main() -&gt; ! {
    let mut xs = Vec::new();

    xs.push(42);
    assert!(xs.pop(), Some(42));

    loop {
        // ..
    }
}</code></pre>
<p>Si has usado las colecciones en la <em>crate</em> <code>std</code> entonces estas te serán familiares ya que son exactamente la misma implementación.</p>
<h2 id="usando-heapless"><a class="header" href="#usando-heapless">Usando <code>heapless</code></a></h2>
<p><code>heapless</code> no requiere configuración ya que sus colecciones no dependen de un asignador de memoria global. Simplemente <code>use</code> sus colecciones y procede a instanciarlas:</p>
<pre><code class="language-rust ignore">// heapless version: v0.4.x
use heapless::Vec;
use heapless::consts::*;

#[entry]
fn main() -&gt; ! {
    let mut xs: Vec&lt;_, U8&gt; = Vec::new();

    xs.push(42).unwrap();
    assert_eq!(xs.pop(), Some(42));
    loop {}
}</code></pre>
<p>Notarás dos diferencias entre estas colecciones y las de <code>alloc</code>.</p>
<p>Primero, tienes que declarar por adelantado la capacidad de la colección. Las colecciones <code>heapless</code> nunca se reasignan y tienen capacidades fijas; esta capacidad forma parte de la firma de tipo de la colección. En este caso hemos declarado que <code>xs</code> tiene una capacidad de 8 elementos, es decir, que el vector puede contener, como máximo, 8 elementos. Esto se indica mediante la <code>U8</code> (véase <a href="https://crates.io/crates/typenum"><code>typenum</code></a>) en la firma de tipo.</p>
<p>En segundo lugar, el método <code>push</code>, y muchos otros métodos, devuelven un <code>Result</code>. Dado que las colecciones <code>heapless</code> tienen una capacidad fija, todas las operaciones que insertan elementos en la colección pueden fallar potencialmente. La API refleja este problema devolviendo un <code>Result</code> que indica si la operación ha tenido éxito o no. Por el contrario, las colecciones <code>alloc</code> se reasignan a sí mismas en el heap para aumentar su capacidad.</p>
<p>A partir de la versión v0.4.x todas las colecciones <code>heapless</code> almacenan todos sus elementos en línea. Esto significa que una operación como <code>let x = heapless::Vec::new();</code> asignará la colección en la pila, pero también es posible asignar la colección en una variable <code>static</code>, o incluso en el montón (<code>Box&lt;Vec&lt;_, _&gt;&gt;</code>).</p>
<h2 id="ventajas-y-desventajas"><a class="header" href="#ventajas-y-desventajas">Ventajas y desventajas</a></h2>
<p>Ten en cuenta lo siguiente a la hora de elegir entre colecciones reubicables asignadas al heap y colecciones de capacidad fija.</p>
<h3 id="out-of-memory-y-gestión-de-errores"><a class="header" href="#out-of-memory-y-gestión-de-errores">Out Of Memory y gestión de errores</a></h3>
<p>Con las asignaciones de heap, el Out Of Memory es siempre una posibilidad y puede ocurrir en cualquier lugar donde una colección pueda necesitar crecer: por ejemplo, todas las invocaciones <code>alloc::Vec.push</code> pueden potencialmente generar una condición OOM. Por tanto, algunas operaciones pueden fallar <em>implícitamente</em>. Algunas colecciones <code>alloc</code> exponen métodos <code>try_reserve</code> que te permiten comprobar posibles condiciones OOM al hacer crecer la colección, pero debes ser proactivo a la hora de utilizarlos.</p>
<p>Si usas exclusivamente colecciones <code>heapless</code> y no usas un asignador de memoria para nada más, entonces una condición OOM es imposible. En su lugar, tendrás que lidiar con las colecciones que se queden sin capacidad caso por caso. Es decir, tendrás que lidiar con <em>todos</em> los <code>Result</code> devueltos por métodos como <code>Vec.push</code>.</p>
<p>Los fallos OOM pueden ser más difíciles de depurar que, por ejemplo, <code>unwrap</code> todos los <code>Result</code> devueltos por <code>heapless::Vec.push</code> porque la localización observada del fallo puede <em>no</em> coincidir con la localización de la causa del problema. Por ejemplo, incluso <code>vec.reserve(1)</code> puede desencadenar un OOM si el asignador está casi agotado porque alguna otra colección estaba perdiendo memoria (las fugas de memoria son posibles en Rust seguro).</p>
<h3 id="uso-de-memoria"><a class="header" href="#uso-de-memoria">Uso de memoria</a></h3>
<p>Razonar sobre el uso de memoria de las colecciones asignadas al heap es difícil porque la capacidad de las colecciones de larga duración puede cambiar en tiempo de ejecución. Algunas operaciones pueden implícitamente reasignar la colección incrementando su uso de memoria, y algunas colecciones exponen métodos como <code>shrink_to_fit</code> que pueden potencialmente reducir la memoria usada por la colección -- en última instancia, depende del asignador decidir si realmente reduce la asignación de memoria o no. Además, el asignador puede tener que lidiar con la fragmentación de la memoria, lo que puede aumentar el uso de memoria <em>aparente</em>.</p>
<p>Por otro lado, si utilizas exclusivamente colecciones de capacidad fija, almacenas la mayoría de ellas en variables <code>static</code> y estableces un tamaño máximo para la pila de llamadas, el enlazador detectará si intentas utilizar más memoria de la que está físicamente disponible.</p>
<p>Además, las colecciones de capacidad fija asignadas en la pila serán reportadas por la bandera <a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html"><code>-Z emit-stack-sizes</code></a> lo que significa que las herramientas que analizan el uso de la pila (como <a href="https://crates.io/crates/stack-sizes"><code>stack-sizes</code></a>) las incluirán en su análisis.</p>
<p>Sin embargo, las colecciones de capacidad fija <em>no</em> pueden reducirse, lo que puede dar lugar a factores de carga (la relación entre el tamaño de la colección y su capacidad) inferiores a los que pueden conseguir las colecciones reubicables.</p>
<h3 id="tiempo-de-ejecución-en-el-peor-de-los-casos-wcet"><a class="header" href="#tiempo-de-ejecución-en-el-peor-de-los-casos-wcet">Tiempo de ejecución en el peor de los casos (WCET)</a></h3>
<p>Si estás construyendo aplicaciones sensibles al tiempo o aplicaciones de tiempo real duro, entonces te preocupas, quizás mucho, por el tiempo de ejecución en el peor de los casos de las diferentes partes de tu programa. Las colecciones <code>alloc</code> pueden reasignarse, por lo que el WCET de las operaciones que pueden hacer crecer la colección también incluirá el tiempo que se tarda en reasignar la colección, que a su vez depende de la capacidad <em>runtime</em> de la colección. Esto dificulta la determinación del WCET de, por ejemplo, la operación <code>alloc::Vec.push</code>, ya que depende tanto del asignador utilizado como de su capacidad en tiempo de ejecución.</p>
<p>Por otro lado, las colecciones de capacidad fija nunca se reasignan, por lo que todas las operaciones tienen un tiempo de ejecución predecible. Por ejemplo, <code>heapless::Vec.push</code> se ejecuta en tiempo constante.</p>
<h3 id="facilidad-de-uso"><a class="header" href="#facilidad-de-uso">Facilidad de uso</a></h3>
<p><code>alloc</code> requiere configurar un asignador global mientras que <code>heapless</code> no. Sin embargo, <code>heapless</code> requiere que elijas la capacidad de cada colección que instales.</p>
<p>La API <code>alloc</code> será familiar para prácticamente todos los desarrolladores de Rust. La API <code>heapless</code> intenta imitar de cerca la API <code>alloc</code> pero nunca será exactamente igual debido a su gestión explícita de errores -- algunos desarrolladores pueden sentir que la gestión explícita de errores es excesiva o demasiado engorrosa.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concurrency/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../design-patterns/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concurrency/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../design-patterns/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
